"""LABELLER MODULE"""


#! IMPORTS


import os
import sys
from types import FunctionType, MethodType
from typing import Any, Iterable

import cv2
import h5py
import numpy as np
from numpy.typing import NDArray
from PySide2.QtCore import QTimer
from PySide2.QtGui import QIcon, QPixmap
from PySide2.QtWidgets import (
    QApplication,
    QFileDialog,
    QHBoxLayout,
    QMessageBox,
    QSizePolicy,
    QVBoxLayout,
    QCheckBox,
    QWidget,
)

from .assets import ICON, as_pixmap
from .segmenters import EllipseSegmenter, Segmenter
from .utils import check_type
from .widgets import (
    QFONT,
    CounterWidget,
    FileBrowseBar,
    ResizableImage,
    SaveBar,
    SegmenterPaneWidget,
    SegmenterWidget,
    get_label,
)

#! CONSTANTS

IMAGE_FORMATS = [
    "bmp",
    "dib",
    "jpeg",
    "jpg",
    "jpe",
    "jp2",
    "png",
    "webp",
    "pbm",
    "pgm",
    "ppm",
    "pxm",
    "pnm",
    "sr",
    "ras",
    "tiff",
    "tif",
    "exr",
    "hdr",
    "pic",
]


#! FUNCTIONS


def read_images(file: str) -> NDArray:
    """
    read the provided file and return the corresponding 3D or 4D array.

    Parameters
    ----------
    file: str
        the directory containing images to be imported or a single file image.

    Returns
    -------
    frames: NDArray
        the image as ndarray.
    """

    def _get_array(f: str) -> NDArray:
        ext = f.rsplit(".", maxsplit=1)[-1]
        if ext not in IMAGE_FORMATS:
            msg = f"{ext} does not comply with the available formats "
            msg += f"({IMAGE_FORMATS})."
            raise TypeError(msg)
        return cv2.cvtColor(cv2.imread(f, cv2.IMREAD_COLOR), cv2.COLOR_BGR2RGBA)

    # check the input
    check_type(file, str)

    # get the frames
    if os.path.isdir(file):
        frames = []
        for f in list(os.walk(file))[-1]:
            try:
                img = _get_array(f)
                frames += [np.expand_dims(img, 0)]
            except TypeError:
                pass
        if len(frames) == 0:
            raise TypeError("No valid images have been found.")
    elif os.path.isfile(file):
        frames = [np.expand_dims(_get_array(file), 0)]
    else:
        raise TypeError("Something wrong occurred.")

    return np.concatenate(frames)


def read_segmentation_masks(file: str) -> tuple[NDArray, dict[str, int]]:
    """
    read a ".h5" file and extract the stored data.

    Parameters
    ----------
    file: str
        the path to the ".h5" file generated by the Labeller.save_masks
        method.

    Returns
    -------
    masks: NDArray
        a 4D numpy array of dtype *bool* with shape *(frames, height, width,
        segmenter)*. Here each *segmenter* corresponds to a specific
        segmentation object.

    labels: dict
        a dict containing the labels of the segmentation masks as keys and
        their indices along the last dimension of *masks* as value.
    """
    # check the input
    check_type(file, str)
    ext = file.rsplit(".", 1)[-1]
    assert ext == "h5", "file must be a '.h5' file."

    # read the data
    with h5py.File(file, "r") as h5obj:
        objs = {}
        for i in ["masks", "labels", "indices"]:
            try:
                objs[i] = h5obj[i][:]  # type: ignore
            except Exception as exc:
                raise ValueError(f"{i} key not found in {file}.") from exc

    # return
    labels = {i: v for i, v in zip(objs["labels"], objs["indices"])}
    return objs["masks"], labels


#! CLASSES


class Labeller(QWidget):
    """
    GUI allowing to interact with the provided labeller and images

    Parameters
    ----------
    segmenters: Iterable[Segmenter] | Segmenter | None, optional
        pregenerated segmenters to be included in the Labeller.

    **formats: Keyworded arguments
        any number of keyworded arguments. Each should be the name of an
        extension file format accepted by the labeller. Each key must have
        an associated Method or Function that allows to extract the frames
        to be labelled from the selected file.
    """

    # ****** VARIABLES ****** #

    _image_widget = None  # the image rendering widget
    _segmenter_pane = None  # the Widget containing the segmenters
    _counter_widget = None  # the Widget containing the position counters
    _options_pane = None  # the widget containing all the options
    _pressed = False  # a state variable used to deal with mouse pressing
    _input_bar = None  # file input bar
    _save_bar = None  # save file button.
    _data_coords = None  # coordinates label.
    _frames = None  # the images to be labelled
    _segmenters = None  # the segmenters to be used.
    _formats = None  # the accepted file formats.
    _last_path = __file__.rsplit(os.path.sep, 1)[0]
    _estimator_checkbox = None

    # ****** CONSTRUCTOR ****** #

    def __init__(
        self,
        segmenters: Segmenter | Iterable[Segmenter] | None = None,
        **formats,
    ) -> None:
        super().__init__()

        # setup the title and app icon
        self.setWindowIcon(QIcon(as_pixmap(ICON)))
        self.setWindowTitle("pyLabeller")

        # setup the image widget
        self._image_widget = ResizableImage()
        self._image_widget.mouse_enter.connect(self._on_enter)
        self._image_widget.mouse_leave.connect(self._on_leave)
        self._image_widget.mouse_moved.connect(self._on_move)
        self._image_widget.mouse_pressed.connect(self._on_press)
        self._image_widget.mouse_released.connect(self._on_release)
        self._image_widget.mouse_doubleclick.connect(self._on_doubleclick)
        self._image_widget.mouse_wheeling.connect(self._on_wheeling)

        # setup the input bar
        if len(formats) == 0:
            formats = {i: read_images for i in IMAGE_FORMATS}
        self.set_formats(formats)
        self._input_bar = FileBrowseBar(list(self.formats.keys()))
        self._input_bar.text_changed.connect(self._on_input_text_changed)
        input_layout = QHBoxLayout()
        input_layout.addWidget(get_label("SOURCE:"))
        input_layout.addWidget(self._input_bar)
        input_widget = QWidget()
        input_widget.setLayout(input_layout)
        min_height = input_widget.minimumSizeHint().height()
        input_widget.setFixedHeight(min_height)

        # set the coordinates bar
        self._data_coords = get_label("")
        self._estimator_checkbox = QCheckBox("ESTIMATOR ENABLED")
        self._estimator_checkbox.setFont(QFONT)
        self._estimator_checkbox.setChecked(True)
        bar_layout = QHBoxLayout()
        bar_layout.addWidget(self._estimator_checkbox)
        bar_layout.addStretch()
        bar_layout.addWidget(get_label("(x, y, z): "))
        bar_layout.addWidget(self._data_coords)
        bar_widget = QWidget()
        bar_widget.setLayout(bar_layout)
        bar_widget.setFixedHeight(min_height)

        # setup the save bar
        self._save_bar = SaveBar(0, 6, 1)
        self._save_bar.started.connect(self._on_save_pressed)
        self._save_bar.completed.connect(self._on_save_completed)

        # setup the right side widget
        right_layout = QVBoxLayout()
        right_layout.addWidget(input_widget)
        right_layout.addWidget(bar_widget)
        right_layout.addWidget(self._image_widget)
        right_layout.addWidget(self._save_bar)
        right_widget = QWidget()
        right_widget.setLayout(right_layout)
        right_widget.setMinimumSize(300, 300)

        # setup the Segmenters Panel
        self._segmenter_pane = SegmenterPaneWidget()
        self._segmenter_pane.added.connect(self._on_added_segmenter)
        self._segmenter_pane.removed.connect(self._on_removed_segmenter)

        # setup the counter box
        self._counter_widget = CounterWidget("FRAME", 0, 0)
        self._counter_widget.move_backward.connect(self._on_backward_pressed)
        self._counter_widget.move_forward.connect(self._on_forward_pressed)
        min_height = self._counter_widget.minimumSizeHint().height()
        self._counter_widget.setFixedHeight(min_height)

        # setup the left pane
        left_layout = QVBoxLayout()
        left_layout.setSpacing(10)
        left_layout.addWidget(self._counter_widget)
        left_layout.addWidget(self._segmenter_pane)
        self._options_pane = QWidget()
        self._options_pane.setLayout(left_layout)

        # setup the main layout
        layout = QHBoxLayout()
        layout.addWidget(self._options_pane)
        layout.addWidget(right_widget)
        self.setLayout(layout)
        policy = self.sizePolicy()
        policy.setHorizontalPolicy(QSizePolicy.MinimumExpanding)
        policy.setVerticalPolicy(QSizePolicy.MinimumExpanding)
        self.setSizePolicy(policy)

        # setup the frames and the segmenters
        self._segmenters = {}
        self.set_frames(np.zeros((1, 160, 90), dtype=np.uint8))

        # add at least one segmenter
        if segmenters is None:
            self.add_segmenters(EllipseSegmenter("SEGMENTER1"))
        else:
            self.add_segmenters(segmenters)

        # make the segmenter pane width fixed
        width = self._options_pane.minimumSizeHint().width()
        self._options_pane.setFixedWidth(width)

        # set the qtimer
        self._timer = QTimer()
        self._timer.setSingleShot(True)
        self._timer.timeout.connect(self.save_masks)

    # ****** SETTERS ****** #

    def set_frames(self, frames: NDArray) -> None:
        """
        set the frames to be labelled.

        Parameters
        ----------
        frames (NDArray):
            a 3D array with shape (frames, height, width) or a 4D
            array with shape (frames, height, width, channels).
        """

        # set the new frames
        check_type(frames, np.ndarray)
        msg = "frames must be a 3D/4D numpy.ndarray with shape:\n"
        msg += " - 3D -> (frame, rows, cols)\n"
        msg += " - 4D -> (frame, rows, cols, rgba)."
        if frames.ndim not in (3, 4):
            raise ValueError(msg)
        self._frames = frames

        # update the counter widget
        self._counter_widget.set_max_counter(frames.shape[0])
        self._counter_widget.set_counter(1)

        # reset the segmenters
        self._segmenters = {}
        for widget in self._segmenter_pane.segmenters:
            sgm = widget.segmenter
            self._segmenters[sgm.name] = [sgm.copy()]

        # update the view
        self._update_view()
        self._update_saving()

    def set_formats(
        self,
        formats: dict[str, MethodType | FunctionType],
    ) -> None:
        """
        set the file browsing file formats.

        Parameters
        ----------
        formats: dict[str, MethodType | FunctionType]
            each key must represents a specific file format supported by the
            Labeller. Each key must correspond to a function accepting
            a string as input (the file selected by the file browser)
            and providing a 3D array with shape (frames, height, width) or a 4D
            array with shape (frames, height, width, channels) as output.
        """
        check_type(formats, dict)
        self._formats = {}
        for key, fun in formats.items():
            check_type(fun, (MethodType, FunctionType))  # type: ignore
            self._formats[key] = fun

    def add_segmenters(self, sgmntr: Segmenter | Iterable[Segmenter]) -> None:
        """
        add a new segmenter to the list of available segmenters.

        Parameters
        ----------
        sgmntr: Segmenter | Iterable[Segmenter]
            the segmenter(s) to be included.
        """
        if isinstance(sgmntr, Segmenter):
            self._segmenter_pane.add_segmenter(sgmntr)
        elif isinstance(sgmntr, Iterable):
            for sgm in sgmntr:
                self._segmenter_pane.add_segmenter(sgm)
        else:
            types = Segmenter | Iterable[Segmenter]
            raise TypeError(f"sgmntr must be a any of {types}")

    def set_coords(self, coords: tuple[int, int] | None) -> None:
        """update the data coordinate label"""
        frm = "({}, {}, {})"
        if coords is None:
            self._data_coords.setText(frm.format(" ", " ", " "))
        else:
            vals = [str(i) for i in coords]
            vals += [str(self.frames[self.current_frame][coords[::-1]])]
            txt = frm.format(*vals)
            self._data_coords.setText(txt)

    def set_input(self, path:str) -> None:
        """
        set the file to be segmented.

        Parameters
        ----------
        path : str
            the path to the file to be automatically loaded once the labeller
            is opened.

        Raises
        ------
        TypeError
            if path is not a str instance or the string does not match
            with the path to an existing file.
        """

        # load the file on path
        if not isinstance(path, str) or not os.path.exists(path):
            raise TypeError("path must be an existing file.")
        self._input_bar._textfield.setText(path)

    # ****** GETTERS ****** #

    @property
    def segmenters(self) -> list:
        """return the list of stored segmenters"""
        return self._segmenters

    @property
    def frames(self) -> NDArray | None:
        """return the list of images."""
        return self._frames

    @property
    def formats(self) -> NDArray | None:
        """return the valid file formats."""
        return self._formats

    @property
    def available_frames(self) -> int:
        """return the number of available images."""
        return self._counter_widget.max_counter - 1

    @property
    def current_frame(self) -> int:
        """get index of the actual image shown."""
        return self._counter_widget.counter - 1

    @property
    def active_segmenter(self) -> Segmenter | None:
        """return the current active segmenter."""
        active = self._segmenter_pane.active_segmenter
        if active is None:
            return None
        return self.segmenters[active.name][self.current_frame]

    @property
    def current_segmenters(self) -> dict:
        """return the segmenters linked to the current frame."""
        if len(self.segmenters) == 0:
            return {}
        return {i: v[self.current_frame] for i, v in self.segmenters.items()}

    @property
    def labels(self) -> dict[str, int] | None:
        """
        return the labels and the index of the segmentation_mask array
        corresponding to the given label.

        Example:

            segmentation_mask[:, :, :, labels["name"]]

            will return the array
            containing all the segmentation mask corresponding to the required
            label.
        """
        if self.segmenters is None:
            return None
        return {v: i for i, v in enumerate(self.segmenters)}

    @property
    def segmentation_mask(self) -> NDArray | None:
        """
        return a 4D numpy array containing the segmentation mask resulting
        from each frame and containing the boolean mask corresponding to each
        segmenter in the last dimension.
        """
        if self.segmenters is None or self.frames is None:
            return None
        shape = self.frames.shape[:3] + (len(self.segmenters),)
        masks = np.zeros(shape, dtype=bool)
        for i, frame in enumerate(self.frames):
            for j, name in enumerate(self.segmenters):
                if len(self.segmenters[name]) > i:
                    segmenter = self.segmenters[name][i]
                    fill, borders = segmenter.mask(frame.shape[:2])
                    if fill is not None and borders is not None:
                        masks[i, :, :, j] = fill | borders
        return masks

    # ****** EVENT HANDLERS ****** #

    def _on_forward_pressed(self) -> None:
        """handle the clicking of the forward button."""
        self._update_segmenters()
        self._update_view()
        self._update_saving()

    def _on_backward_pressed(self) -> None:
        """handle the clicking of the backward button."""
        self._update_view()

    def _on_input_text_changed(self, text: str) -> None:
        """handle the change in the file browse textfield."""

        # ensure that the current file has the appropriate file format.
        check_type(text, str)
        ext = text.rsplit(".", maxsplit=1)[-1]
        if ext not in list(self.formats.keys()):
            QMessageBox.warning(
                self,
                "Invalid format",
                f"{self.text} has an invalid file format.",
            )

        # extract the new frames
        self.set_frames(self.formats[ext](text))

    def _on_save_pressed(self) -> None:
        """handle the press of the save button"""
        self._timer.start()

    def _on_save_completed(self) -> None:
        """inform about the end of the saving procedure"""
        msg = "Saving procedure complete."
        QMessageBox.information(self, "Saving complete", msg)

    def _on_added_segmenter(self, segmenter: SegmenterWidget) -> None:
        """handle the inclusion of a novel segmenter."""
        # add event handlers to the segmenter
        segmenter.name_changed.connect(self._on_name_changed)
        segmenter.color_changed.connect(self._on_color_changed)
        segmenter.linewidth_changed.connect(self._on_linewidth_changed)
        segmenter.fontsize_changed.connect(self._on_fontsize_changed)
        segmenter.text_checked.connect(self._on_widget_text_checked)

        # add the segmenting list and update
        self.segmenters[segmenter.segmenter.name] = [segmenter.segmenter.copy()]
        self._update_segmenters()
        self._update_view()

    def _on_removed_segmenter(self, segmenter: SegmenterWidget) -> None:
        """handle the removal of a segmenter."""
        removed = self.segmenters.pop(segmenter.segmenter.name)
        del removed
        self._update_segmenters()
        self._update_view()

    def _on_name_changed(
        self,
        source: SegmenterWidget,
        old: str,
        new: str,
    ) -> None:
        """handle the renaming action on one segmenter."""
        if old in [i for i in self.segmenters]:
            self.segmenters[new] = self.segmenters[old].copy()
            self.segmenters.pop(old)
        else:
            self.segmenters[new] = [source.segment.copy()]
        for segmenter in self.segmenters[new]:
            segmenter.set_name(new)
        self._update_segmenters()
        self._update_view()

    def _on_color_changed(
        self,
        source: SegmenterWidget,
        new: str,
    ) -> None:
        """handle the change in color of one segmenter."""
        for i in self.segmenters[source.segmenter.name]:
            i.set_color(new)
        self._update_view()

    def _on_fontsize_changed(
        self,
        source: SegmenterWidget,
        new: float,
    ) -> None:
        """handle the change in fontsize of one segmenter."""
        for i in self.segmenters[source.segmenter.name]:
            i.set_fontsize(int(new))
        self._update_view()

    def _on_linewidth_changed(
        self,
        source: SegmenterWidget,
        new: float,
    ) -> None:
        """handle the change in linewidth of one segmenter."""
        for i in self.segmenters[source.segmenter.name]:
            i.set_linewidth(int(new))
        self._update_view()

    def _on_widget_text_checked(self, source: SegmenterWidget) -> None:
        """handle the check/uncheck of the segmenter widgets text checkbox."""
        self._update_view()

    def _on_enter(self, coords: tuple[int, int] | None) -> None:
        """handle the mouse entering action"""
        self.set_coords(coords)

    def _on_leave(self, coords: tuple[int, int] | None) -> None:
        """handle the mouse leaving action"""
        self.set_coords(coords)

    def _on_press(self, coords: tuple[int, int] | None) -> None:
        """handle the mouse clicking action"""
        # activate the clicked segmenter
        widgets = self._segmenter_pane.segmenters[::-1]
        for key, segmenter in self.current_segmenters.items():
            if segmenter.isin(coords):
                widget = [i for i in widgets if i.segmenter.name == key][0]
                if not widget.is_checked():
                    widget.click()
                    break

        # edit the active segmenter
        segmenter = self.active_segmenter
        if segmenter is not None:
            self._pressed = True
            if len(segmenter.points) == 0:
                segmenter.add_point(coords)
            elif segmenter.is_drawable():
                segmenter.set_selected(segmenter.isin(coords))

    def _on_doubleclick(self, coords: tuple[int, int, Any] | None) -> None:
        """handle the mouse clicking action"""
        self._pressed = False
        segmenter = self.active_segmenter
        if segmenter is not None:
            segmenter.del_points()
            segmenter.set_selected(False)
            segmenter.set_angle(0)
            self._update_view()

    def _on_move(self, coords: tuple[int, int] | None) -> None:
        """handle the mouse motion action"""
        self.set_coords(coords)
        segmenter = self.active_segmenter
        if segmenter is not None and self._is_mouse_pressed():
            if segmenter.is_drawable():
                if segmenter.is_selected():
                    segmenter.shift(coords)
                    self._update_view()
            else:
                segmenter.add_point(coords, 1)
                self._update_view()
                segmenter.del_points(1)

    def _on_release(self, coords: tuple[int, int, Any] | None) -> None:
        """handle the mouse releasing action"""
        self._pressed = False
        segmenter = self.active_segmenter
        if segmenter is not None:
            if len(segmenter.points) == 1:
                segmenter.add_point(coords, 1)
            self._update_view()
            segmenter.set_selected(False)

    def _on_wheeling(self, ticks: int | None) -> None:
        """handle the mouse wheel action"""
        self._pressed = False
        segmenter = self.active_segmenter
        if segmenter is not None and segmenter.is_drawable():
            segmenter.set_angle(segmenter.angle + ticks)
            self._update_view()

    # ****** METHODS ****** #

    def _estimate_new_segmenter(
        self,
        old_image: NDArray,
        new_image: NDArray,
        old_segmenter: Segmenter,
    ) -> Segmenter:
        """
        estimate the shift in the old_segmenter position according to the
        new image in order to maximize the the 2D cross-correlation.

        Paramters
        ---------
            old_image: (NDArray)
                the image on which the old_segmenter has been generated.

            new_image: (NDArray)
                the image on which the new_segmenter has to be shifted.

            old_segmenter: (Segmenter)
                the segmenter generated on old_image.

        Returns:
            new_segmenter (Segmenter):
                the shifted segmenter.
        """
        # check the inputs
        check_type(old_image, np.ndarray)
        check_type(new_image, np.ndarray)
        check_type(old_segmenter, Segmenter)
        shape_ok = all(i == v for i, v in zip(old_image.shape, new_image.shape))
        assert shape_ok, "new_image and old_image must have the same shape."

        # check if the estimate can be obtained
        new_segmenter = old_segmenter.copy()
        if not old_segmenter.is_drawable():
            return new_segmenter

        # get the template
        fill, borders = old_segmenter.mask(old_image.shape[:2])[:2]
        ym, xm = np.where(fill | borders)
        xmin, xmax = np.min(xm), np.max(xm) + 1
        ymin, ymax = np.min(ym), np.max(ym) + 1
        old_mask = old_image[ymin:ymax, xmin:xmax]

        # convert to uint8
        def float2int(
            mask: NDArray,
            maxv: float,
            minv: float,
        ) -> NDArray[np.uint8]:
            return ((mask - minv) / (maxv - minv) * 255).astype(np.uint8)

        template = float2int(old_mask, np.max(old_mask), np.min(old_mask))

        # get the top-left corner of the segmenter bbox
        old_corner = np.array([np.min(xm), np.min(ym)])

        # get template matching method
        img = float2int(new_image, np.max(new_image), np.min(new_image))
        new_corner = []
        methods = [
            cv2.TM_CCOEFF,
            cv2.TM_CCORR,
            cv2.TM_SQDIFF,
            cv2.TM_CCOEFF_NORMED,
            cv2.TM_CCORR_NORMED,
            cv2.TM_SQDIFF_NORMED,
        ]
        for method in methods:
            res = cv2.matchTemplate(img, template, method)
            min_loc, max_loc = cv2.minMaxLoc(res)[-2:]
            if method in [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]:
                top_left_corner = min_loc
            else:
                top_left_corner = max_loc
            new_corner += [np.atleast_2d(top_left_corner)]
        new_corner = np.median(np.vstack(new_corner), axis=0)
        delta = new_corner - old_corner

        # find the best match and update the position of the new segmenter
        new_center = (np.array(old_segmenter.center) + delta).astype(int)
        new_segmenter.shift(new_center.tolist())
        return new_segmenter

    def _is_mouse_pressed(self) -> bool:
        """return whether the mouse is pressed on the figure."""
        return self._pressed

    def _update_view(self) -> None:
        """update the current artist to the actual counter."""
        if self.frames.shape[0] > 0:
            # get the image
            img = np.squeeze(self.frames[self.current_frame])

            # apply the correct colormap
            if img.ndim == 2:
                miv = np.min(img)
                mav = np.max(img) - miv
                if mav == 0:
                    nrm = np.zeros_like(img, dtype=np.uint8)
                else:
                    nrm = np.round(((img - miv) / mav) * 255).astype(np.uint8)
                cmap = cv2.applyColorMap(nrm, cv2.COLORMAP_VIRIDIS)
                alpha = np.ones(nrm.shape + (1,), dtype=np.uint8) * 255
                cmap = np.concatenate([cmap, alpha], axis=-1)
            else:
                cmap = img.astype(np.uint8)

            # apply the segmenters
            for segmenter in self.current_segmenters.values():
                if segmenter.is_drawable():
                    objs = segmenter.overlay(cmap)
                    if objs[0] is not None:
                        wdgts = self._segmenter_pane.segmenters
                        name = segmenter.name
                        widget = [i for i in wdgts if i.segmenter.name == name]
                        widget = widget[0]
                        if not widget.is_text_enabled():
                            objs = objs[:-1]
                        for mask in objs:
                            idx = np.where(mask > 0)
                            cmap[idx] = mask[idx]

            # update the view
            self._image_widget.set_ndarray(cmap)

    def _update_segmenters(self) -> None:
        """update the segmenters map to the actual state of the labeller."""
        for val in self.segmenters.values():
            while len(val) <= self.current_frame:
                if self._estimator_checkbox.isChecked():
                    new_segmenter = self._estimate_new_segmenter(
                        old_image=self.frames[self.current_frame - 1],
                        new_image=self.frames[self.current_frame],
                        old_segmenter=val[-1],
                    )
                else:
                    new_segmenter = val[-1].copy()
                val += [new_segmenter]

    def _update_saving(self) -> None:
        """update the save button."""
        state = self.current_frame == self.available_frames
        self._save_bar.setEnabled(state)

    def save_masks(self) -> None:
        """saving function used by QTimer"""

        # get the saving file
        file = QFileDialog.getSaveFileName(
            self,
            "Save File",
            self._last_path,
            "File Format (*.h5)",
        )
        if file is None:
            self._save_bar.reset()
        else:

            # update the path and the file
            file = file[0].replace("/", os.path.sep)
            self._last_path = file.rsplit(os.path.sep, 1)[0]

            # get the labels
            objs = {}
            labels = self.labels
            objs["labels"] = list(labels.keys())
            objs["indices"] = list(labels.values())
            self._save_bar.update()

            # get the masks
            objs["masks"] = self.segmentation_mask
            self._save_bar.update()

            # store the data
            obj = h5py.File(file, "w")
            for key, value in objs.items():
                obj.create_dataset(
                    key,
                    data=value,
                    compression="gzip",
                    compression_opts=9,
                )
                self._save_bar.update()
            obj.close()
            self._save_bar.update()

        # stop the timer
        self._timer.stop()


#! MAIN

if __name__ == "__main__":
    app = QApplication(sys.argv)
    labeller = Labeller()
    labeller.show()
    sys.exit(app.exec_())
